package {{pkg}}
import org.openjdk.jmh.annotations._
import java.util.concurrent.TimeUnit

import scala.tools.nsc.{Global, Settings, Mode => nscMode}
import scala.tools.nsc.io._
import scala.tools.nsc.reporters._
import java.io._
import scala.reflect.internal.util.BatchSourceFile

@BenchmarkMode(Array(Mode.SingleShotTime))
@OutputTimeUnit(TimeUnit.SECONDS)
@State(Scope.Benchmark)
class {{name}} {

  // benchmark.jar generated by JMH contains everything needed...
  val benchmarkCP = (getClass.getClassLoader match {
    case u: java.net.URLClassLoader => u.getURLs()
    case _ => Array[String]()
  }).mkString(":")

  // inspired by https://github.com/scala-records/scala-records-benchmarks
  val compSettings = new Settings()
  compSettings.encoding.value = "UTF-8"
  compSettings.classpath.value = benchmarkCP // ...so let's use it for compilation dependencies!!! (inception)
  compSettings.bootclasspath.value = benchmarkCP
  //compSettings.processArguments(List("-Ystop-after:typer"),true)
  //compSettings.outdir.value = "."
  val fileSystem = new VirtualDirectory("<vfs>", None)
  compSettings.outputDirs.setSingleOutput(fileSystem)
  val cReporter = new ConsoleReporter(compSettings, null, new PrintWriter(System.out))
  val compiler = new Global(compSettings, cReporter)
  var run: compiler.Run = _

  @Setup(Level.Iteration)
  def setupIteration = {
    run = new compiler.Run
  }

{{snippets}}

{{methods}}

  @TearDown(Level.Iteration)
  def teardownIteration = {
      cReporter.printSummary()
      if(cReporter.hasErrors || cReporter.hasWarnings)
        sys.exit(1)
  }

}
